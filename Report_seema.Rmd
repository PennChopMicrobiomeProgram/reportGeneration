---
title: "Basic Bioinformatics Overview"
author: "PennCHOP Microbiome Program"
date: "December 22, 2015"
output: pdf_document
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

```{r, message=FALSE, warning=FALSE}
library(pheatmap)
#library(png)
library(grid)
library(pander)
library(stringr)
library(qiimer)
library(vegan)
library(ape)
library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
```


```{r sample_sheet_import, echo=FALSE}
mapping_file_name <- "metadata.txt"
s <- read.table(mapping_file_name, sep='\t',  header=TRUE, stringsAsFactors = FALSE)
s$SampleID <- as.character(s$SampleID)

color_by <- ''
shape_by <- ''
potential_headers <- c('study_group', 'study_day', 'current_antibiotics', 'cage_number', 'mouse_strain')
header_idx <- which(is.element(potential_headers, colnames(s)))

if(length(header_idx)>0){
  color_by <- potential_headers[header_idx[1]]
}
if(length(header_idx)>1){
  shape_by <- potential_headers[header_idx[2]]
}

quality_summary_headers <- c('SampleType', 'study_day')
header_idx <- which(is.element(quality_summary_headers, colnames(s)))
quality_by <- ifelse(length(header_idx)>0, quality_summary_headers[header_idx[1]], '')
```

# Introduction
*Insert project specific paragraph here*

\newpage

# Demultiplexing and quality control
Samples were sequences on Hiseq 2500 and were demultiplexed and analyzed for sequencing quality using FASTQC. The demultiplexing step involves identifing DNA barcodes from the high-throughput data files generated from the Hiseq run. Reads for each sample sequenced is identified by matching the barcode associated with the samples and the data is then outputted in fastq format with each sample having one forward and reverse strand fastq file.

Nextera-XT adapters were used while sequencing which were removed by the trimming of adapters using trimmomatic-0.33. A second quality control step using FASTQC was performed to check quality of sequences after adapter trimming.

###Figure 1: Number of read pairs per sample after demultiplexing

```{r,fig.width=7, fig.height=5, fig.align='center', echo=FALSE}
read.table("preprocess_summary.tsv", header = T) %>%
  mutate(Samples = sub(".json", "", Samples)) %>%
  mutate(num_seq=input/1000000) %>%
  filter(!grepl('positive|negative|vibriolambda|crypto|blank|environmental|mock', Samples, ignore.case=TRUE)) %>%
  ggplot(aes(x=num_seq)) +
    geom_histogram(binwidth = 2) +
    theme_classic() +
    theme_bw() + 
    xlab("Number of read pairs in sample (millions, M)") +
    ylab("Number of samples")
#ggsave(filename="summary_dnabc.pdf", width=7, height=5, units='in')
```

\newpage

###Figure 2: Average nucleotide quality after adapter trimming and quality control


```{r,fig.width=7, fig.height=5, fig.align='center', echo=FALSE}
fp = file.path('fastqc_after_trim_quality.tsv')

rexp <- "^(.*)_(R[12])$"
quality <- read.table(fp, sep='\t', header=TRUE) %>%
  melt(id.vars="Samples", variable.name="Position", value.name = "Quality") %>%
  mutate(
    Position = sub("X", "", Position),
    Position = sub("\\.\\d+", "", Position, perl = TRUE),
    Position = as.numeric(Position),
    Samples = sub("PCMP_", "", Samples, fixed = TRUE)) %>%
  mutate(Sample=sub(rexp,"\\1",Samples), Direction=sub(rexp,"\\2",Samples)) %>%
  mutate(Direction = factor(Direction))

ave_quality <- group_by(quality, Direction, Position) %>%
  summarise(MeanQual = mean(Quality), SdQual = sd(Quality)) %>%
  mutate(LowQual = MeanQual - SdQual, HighQual = MeanQual + SdQual)

ggplot(ave_quality, aes(x=Position, y=MeanQual)) + 
  geom_errorbar(aes(ymin=LowQual, ymax=HighQual)) +
  facet_wrap(~ Direction) +
  geom_line() +
  geom_point() +
  theme_bw() + 
  labs(x='Position in sequence read', y='Average quality score per sample')
#ggsave(filename='quality_after.pdf', width=7, height=5, units='in')
```


Nextera-XT adapters were trimmed using trimmomatic and Table 1 (see Appendix) shows the number of sequenced reads and number reads retrieved from both strands after adapter trimming. Human DNA was filtered using BWA with HG38 version of human genome as reference. At the end of the filtering step the reads were divided into 2 files containing Human DNA and non-human DNA for each sample. Table 2 (see Appendix) list out the number of human and non-human reads and the human percentage in the samples.

\newpage

###Figure 3: Overall distribution of percentage reads removed in quality control

```{r,fig.width=5, fig.height=3, fig.align='center', echo=FALSE}
preprocess <- read.table("preprocess_summary.tsv", header = T) %>%
  mutate(Samples = sub(".json", "", Samples)) %>%
  mutate(low_quality = (fwd_only + rev_only + dropped) / input) %>%
  mutate(human = true / input) %>%
  mutate(non_human = false / input) %>%
  filter(!grepl('positive|negative|vibriolambda|crypto|blank|environmental|mock', Samples, ignore.case=TRUE)) %>%
  slice(order(.$human, decreasing=TRUE)) %>%
  mutate(Sample_num=1:dim(.)[1]) %>%
  merge(s, by.y="SampleID", by.x="Samples") %>%
  melt(c("Sample_num", quality_by), c("low_quality", "human", "non_human"))

num_rows <- length(unique(preprocess[quality_by]))

ggplot(preprocess, aes(x=Sample_num, y=value)) +
  geom_area(aes(fill=variable), position='stack') + 
  facet_wrap(as.formula(paste("~", quality_by)), scales = "free_x", nrow = num_rows) +
  scale_fill_brewer(palette="Set1") + 
  theme(axis.text.x = element_blank()) +
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0)) +
  labs(x="Samples", y="Percentage of reads", fill="")
#ggsave(filename='preprocess_summary.pdf', width=5, height=7, units='in')
```

# Taxonomic assignments

Taxonomic assignments were performned using the MetaPhlAn2 program. This software uses a small database of clade-specific marker genes to identify bacterial, fungal, archaeal, and viral taxa in shotgun metagenomics data.  This method sometimes misses low-abundance organisms because of the small database size.  However, taxa identified here are very likely to be authentically present in the data.

Heatmap charts were generated from the taxonomic assignments.  Please see the attached files, `taxonomic_assignments_clustered.pdf` and `taxonomic_assignments_unclustered.pdf`.  In the heatmap charts, each column represents one sample and each row represents one taxon (typically a species).  In the clustered file, samples were arranged by percentage of shared species.  Species were included in the chart if the abundance in any sample exceeded 1%.

The chart is colored white if species were not observed in the sample, dark blue if species were observed at very low abundance.  This allows the reader to quickly survey species presence/absence.  Abundance values exceeding 50% are colored red, indicating an extremely dominant species.

```{r,  echo=FALSE}
remove_rank_prefix <- function (x) {
  gsub("[kpcofgs]__", "", x, perl=TRUE)
}

replace_underscores <- function (x) {
  gsub("_+", " ", x, perl=TRUE)
}

read_metaphlan2_table <- function (filepath, sample_prefix="PCMP_") {
  df <- read.delim(filepath, comment.char="#")
  props <- as.matrix(df[,-1])
  colnames(props) <- sub(sample_prefix, "", colnames(props), fixed = TRUE)
  rownames(props) <- replace_underscores(remove_rank_prefix(df[,1]))
  props
}

props <- read_metaphlan2_table("taxonomic_assignments.tsv")
lab_control_idx <- grep('positive|negative|vibriolambda|crypto|blank|environmental|mock', colnames(props), ignore.case = TRUE)
props <- props[,-lab_control_idx]

adf <- split_assignments(rownames(props), split = "\\|")
a <- simplify_assignments(adf, rank2 = "Species")
```

```{r}
plotdata <- props
rownames(plotdata) <- a
maxprops <- apply(plotdata, 1, max)
plotdata <- plotdata[maxprops >= 1,]

plotcolors <- saturated_rainbow(100, saturation_limit = 0.6)
plotbreaks <- c(0, 1e-8, 2:100)

pheatmap(
  plotdata,
  color = plotcolors, breaks = plotbreaks,
  clustering_distance_rows = "binary",
  clustering_distance_cols = "binary",
  main = "Taxa identified by clade-specific marker genes (metaphlan2)",
  filename = "taxonomic_assignments_clustered.pdf",
  cellwidth = 9, cellheight = 9, fontsize = 10)

pheatmap(
  plotdata,
  color = plotcolors, breaks = plotbreaks,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  main = "Taxa identified by clade-specific marker genes (metaphlan2)",
  filename = "taxonomic_assignments_unclustered.pdf",
  cellwidth = 9, cellheight = 9, fontsize = 10)
```

\newpage

#### Distance analysis: abundance weighted

Here, we use Bray-Curtis distance to compare the species composition of the samples to each other.

The first plot shows the distance between each pair of samples in a single 2D plot.  It is not possible to plot the distances exactly on paper, so we have used a method of ordination called Principal Coordinates Analysis to select the best coordinate system for display.  The percentage of total variance captured along each axis is displayed on the chart.  It is typical for the percentage to be somewhat low if there are many samples, all different in a variety of ways.

```{r}
matrix_to_sample_df <- function (x) {
  df <- data.frame(SampleID=rownames(x), stringsAsFactors = FALSE)
  cbind(df, x)
}

bc <- vegdist(t(props))
pc <- pcoa(bc)
pc_df <- matrix_to_sample_df(pc$vectors[,1:3]) %>%
  inner_join(s, by="SampleID")

pc_pct <- round(pc$values$Relative_eig * 100)
```

###Figure 4: Ordination based on Bray-Curtis distance

```{r, fig.width=6, fig.height=5}
g_bray = ggplot(pc_df, aes_string(x="Axis.1", y="Axis.2")) +
  #geom_point(aes_string(x="Axis.1", y="Axis.2", color=color_by)) +
  theme_bw() +
  scale_shape_discrete(name=shape_by) + 
  scale_colour_discrete(name=color_by) +
  labs(
    #title = 'Ordination based on Bray-Curtis distance',
    x = paste0("PCoA axis 1 (", pc_pct[1], "%)"),
    y = paste0("PCoA axis 2 (", pc_pct[2], "%)"))

if (shape_by == '' & color_by!='') {
  g_bray <- g_bray + geom_point(aes(colour=factor(get(color_by))))
} else if (shape_by!='' & color_by!='') {
  g_bray <- g_bray + geom_point(aes(colour=factor(get(color_by)), shape=factor(get(shape_by))))
} else {
  g_bray <- g_bray + geom_point()
}
show(g_bray)
```

\newpage

The second plot shows sample clustering based on Bray-Curtis distance.  We have used a method of hierarchical clustering called "average-linkage" or UPGMA.  At the bottom of the dendrogram, all samples start out in their own group.  Moving up the dendrogram, samples accumulate into clusters if the average (mean) distance between all samples is below the indicated value.

###Figure 5: Hierarchical clustering based on Bray-Curtis distance

```{r, fig.width=6, fig.height=6}
bc_upgma <- hclust(bc, method = "average")
par(cex=0.5)
plot(
  bc_upgma, hang=-1, main="",
  ylab = "Bray-Curtis distance",
  xlab="Hierarchical clsutering",
  sub="Average-linkage method (UPGMA)")
par(cex=1)
```

\newpage

#### Distance analysis: presence-absence

Here, we use Jaccard distance to compare samples based on shared species membership.  Plots are described above.

```{r}
jc <- dist(t(props), method = "binary")
pc <- pcoa(jc)

pc_df <- matrix_to_sample_df(pc$vectors[,1:3]) %>%
  inner_join(s, by="SampleID")

pc_pct <- round(pc$values$Relative_eig * 100)
```

###Figure 6: Ordination based on Jaccard distance

```{r, fig.width=6, fig.height=5}
g_jac = ggplot(pc_df, aes_string(x="Axis.1", y="Axis.2")) +
  #geom_point(aes_string(x="Axis.1", y="Axis.2", color=color_by)) +
  theme_bw() +
  scale_shape_discrete(name=shape_by) + 
  scale_colour_discrete(name=color_by) +
  labs(
    #title = 'Ordination based on Jaccard distance',
    x = paste0("PCoA axis 1 (", pc_pct[1], "%)"),
    y = paste0("PCoA axis 2 (", pc_pct[2], "%)"))

if (shape_by == '' & color_by!='') {
  g_jac <- g_jac + geom_point(aes(colour=factor(get(color_by))))
} else if (shape_by!='' & color_by!='') {
  g_jac <- g_jac + geom_point(aes(colour=factor(get(color_by)), shape=factor(get(shape_by))))
} else {
  g_jac <- g_jac + geom_point()
}
show(g_jac)
```

\newpage

###Figure 7: Hierarchical clustering based on Jaccard distance

```{r, fig.width=6, fig.height=6}
bc_upgma <- hclust(bc, method = "average")
par(cex=0.5)
plot(
  bc_upgma, hang=-1, main="",
  ylab = "Jaccard distance",
  xlab="Hierarchical clsutering",
  sub="Average-linkage method (UPGMA)")
par(cex=1)
```

\newpage

# Functional assignment of reads matching to known genes
Abundance of Kyoto Encyclopedia of Genes and Genomes (KEGG) orthologs (KO) were calculated. Here, we use Bray-Curtis distance to compare the KO composition of the samples to each other.

###Figure 8: Ordination based on Bray-Curtis distance for KEGG orthology assignments

```{r,echo=FALSE}
ko <- read.table("ko_assignments.tsv", sep='\t', header=TRUE, stringsAsFactors = FALSE, row.names = 1)
lab_control_idx <- grep('positive|negative|vibriolambda|crypto|blank|environmental|mock', colnames(ko), ignore.case = TRUE)
ko <- ko[,-lab_control_idx]

ko <- sweep(ko, 2, colSums(ko), "/")

bc <- vegdist(t(ko), method='bray')
ko_pca <- pcoa(bc)

temp_vectors <- ko_pca$vectors[, 1:5]
rownames(temp_vectors) <- gsub('PCMP_', '', rownames(temp_vectors))
#temp_vectors <- temp_vectors[s$SampleID,]

ko_df <- merge(s, temp_vectors, by.x="SampleID", by.y="row.names")
ko_pct <- round(ko_pca$values$Relative_eig * 100)

g_uu <- ggplot(ko_df, aes(x=Axis.1, y=Axis.2)) +
  coord_equal() +
  theme_bw() +
  scale_shape_discrete(name=shape_by) + 
  scale_colour_discrete(name=color_by) +
  labs(
    #title = 'PCoA plot based on Bray-Curtis distances',
    x = paste0("PCoA axis 1 (", pc_pct[1], "%)"),
    y = paste0("PCoA axis 2 (", pc_pct[2], "%)"))

if (shape_by =='' & color_by!='') {
  g_uu <- g_uu + geom_point(aes(colour=factor(get(color_by))))
} else if (shape_by!='' & color_by!='') {
  g_uu <- g_uu + geom_point(aes(colour=factor(get(color_by)), shape=factor(get(shape_by))))
} else {
  g_uu <- g_uu + geom_point()
}
show(g_uu)
```

A heatmap of the gene proportions is included in the attached file, `gene_function_assignments.pdf`.  The top 75 gene categories are shown, selected by mean abundance.  Samples and gene categories are clustered by Canberra distance.

```{r}
top_ko <- names(sort(rowMeans(ko), decreasing = TRUE))[1:75]
ko_heatmap <- ko[rownames(ko) %in% top_ko,]
pheatmap(
  ko_heatmap,
  filename = "gene_function_assignments.pdf",
  clustering_distance_rows = "canberra",
  clustering_distance_cols = "canberra",
  cellwidth = 9, cellheight = 9, fontsize = 10)
```

\newpage

# Appendix

###Table 1: Number of reads before and after trimmming Illumina adapter sequences with Trimmomatic.

```{r, echo=FALSE}
read.table("preprocess_summary.tsv", header = T) %>%
  mutate(Samples = sub(".json", "", Samples, fixed = TRUE)) %>%
  select(
    Sample = Samples,
    Input = input,
    Dropped = dropped,
    `Forward only` = fwd_only,
    `Reverse only` = rev_only,
    `Both kept` = both_kept) %>%
  pander(split.table = Inf)
```

###Table 2: Number of reads before and after filtering of host genome sequence.

```{r, echo=FALSE}
read.table("preprocess_summary.tsv", header = T) %>%
  mutate(Samples = sub(".json", "", Samples, fixed = TRUE)) %>%
  mutate(
    `Percent host reads` = 100 * true / (true + false),
    `Percent host reads` = round(`Percent host reads`, 2)) %>%
  select(
    Sample = Samples,
    `Host reads` = true,
    `Non-host reads` = false,
    `Percent host reads`) %>%
  pander(split.table = Inf)
```



