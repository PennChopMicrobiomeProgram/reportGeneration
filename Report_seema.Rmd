---
title: "Basic Bioinformatics Overview"
author: "PennChop Microbiome Program"
date: "December 22, 2015"
output: pdf_document
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

```{r, message=FALSE, warning=FALSE}
library(pheatmap)
library(rjson)
library(png)
library(grid)
library(pander)
library(stringr)
library(qiimer)
library(vegan)
library(ape)
library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
```


```{r sample_sheet_import, echo=FALSE}
mapping_file_name <- "20151210_seema_metadata.txt"
s <- read.table(mapping_file_name, sep='\t',  header=TRUE, stringsAsFactors = FALSE)
s$SampleID <- as.character(s$SampleID)

color_by <- ''
shape_by <- ''
potential_headers <- c('study_group', 'study_day', 'current_antibiotics', 'cage_number', 'mouse_strain')
header_idx <- which(is.element(potential_headers, colnames(s)))

if(length(header_idx)>0){
  color_by <- potential_headers[header_idx[1]]
}
if(length(header_idx)>1){
  shape_by <- potential_headers[header_idx[2]]
}
```

### Introduction
In our previous working adult, male rats, we found that a sub-population exposed to chronic social defeat over 5-7 days exhibits behavioral vurnerability (increased passive coping, anxiety-like and depressive-like behavior) whereas the other sub-population exhibits resilience to these effects of defeat. Our overall goal is to understand the neural mechanisms that produce vulnerability and resilence in order to reduce vulnerability and promote resilence. This work has transational relevance because chronic stress is associated with post-traumatic stress disorder and depression. We have also determined that circulating microRNA profiles of rats that go on to be vulnerable are different. Thus, we are interested in biomarkers that can predict future vulnerability or resilience.

This project has three goals and purposes to use fecal samples.

Goal 1:
To determine whether vulnerable and resilient rats have different gut microbiome profiles.
Hypothesis: Rats vulnerable to stress will exhibit a different gut microbiome profile compared to resilient or non-stressed controls.

Goal 2:
To determine whether the gut microbiome profile at pre-stress timepoints is different before the rats become resilient or vurnerable.
Hypothesis: Gut microbiome profiles prior to stress may predict which individuals will be vunerable or resilient to future mess.

Goal 3:
To determine whether vulnerable rats can be made resilient by pair-housing with a resilient rats.
Hypothesis: Such pair-housing may shift the vulnerable phenotype to a resilient one due to transfer of microbiome through coprophagia.

Overall:
Goal 1 and 2 can be achieved through a single experiment with three group of rats (control, resilient, vulnerable) and fecal samples collected pre-stress and after the stress phenotype is established. Goal 3 is a bigger study requiring more controls. Woulds also serve to validate the initial findings in a seperate cohort of animals in addition to testing a novel way to promote resilience.

### Demultiplexing and quality control
Samples were sequences on Hiseq 2000 and were demultiplexed and analyzed for sequencing quality using FASTQC. The demultiplexing step involves identifing DNA barcodes from the high-throughput data files generated from the Hiseq run. Reads for each sample sequenced is identified by matching the barcode associated with the samples and the data is then outputted in fastq format with each sample having one forward and reverse strand fastq file.

Nextera-XT adapters were used while sequencing which were removed by the trimming of adapters using trimmomatic-0.33. A second quality control step using FASTQC was performed to check quality of sequences after adapter trimming.

**Figure 1: Number of read pairs in samples after demultiplexing**


```{r,fig.width=7, fig.height=5, fig.align='center', echo=FALSE}
fp = file.path('summary-dnabc.json')
save_fp = gsub(pattern = ".json", replacement = ".pdf", fp)
save_fp_txt = gsub(pattern = ".json", replacement = ".txt", fp)

json_data <- fromJSON(file=fp)
data = t(data.frame(json_data$data)) # this line may need work
num_seq = data.frame(numSeq = data[,1], count = data[,1]/1000000)

num_seq$toPlot = row.names(num_seq) != 'unassigned'
num_seq$toPlot[grep('negative|vibriolambda|crypto', row.names(num_seq))] = FALSE

write.table(data, file=save_fp_txt, quote=FALSE, col.names=FALSE, sep='\t')

ggplot(num_seq[num_seq$toPlot,], aes(x=count)) +
  geom_histogram(binwidth = 0.5) +
  theme_classic() +
  theme_bw() + 
  xlab("Number of read pairs in sample (millions, M)") +
  ylab("Number of samples") 
ggsave(filename=save_fp, width=7, height=5, units='in')
```

**Figure 2: Average nucleotide quality after adapter trimming and quality control**


```{r,fig.width=7, fig.height=5, fig.align='center', echo=FALSE}
fp = file.path('fastqc_after_trim_quality.tsv')

quality <- read.table(fp, sep='\t', header=TRUE) %>%
  rename(Sample = Samples) %>%
  melt(id.vars="Sample", variable.name="Position", value.name = "Quality") %>%
  mutate(
    Position = sub("X", "", Position),
    Position = sub("\\.\\d+", "", Position, perl = TRUE),
    Position = as.numeric(Position),
    Sample = sub("PCMP_", "", Sample, fixed = TRUE)) %>%
  separate(Sample, c("Sample", "Direction"), sep="_") %>%
  mutate(Direction = factor(Direction))

ave_quality <- group_by(quality, Direction, Position) %>%
  summarise(MeanQual = mean(Quality), SdQual = sd(Quality)) %>%
  mutate(LowQual = MeanQual - SdQual, HighQual = MeanQual + SdQual)

ggplot(ave_quality, aes(x=Position, y=MeanQual)) + 
  geom_errorbar(aes(ymin=LowQual, ymax=HighQual)) +
  facet_wrap(~ Direction) +
  geom_line() +
  geom_point() +
  theme_bw() + 
  labs(x='Position in sequence read', y='Average quality score per sample')
ggsave(filename='quality_after.pdf', width=7, height=5, units='in')

```


Nextera-XT adapters were trimmed using trimmomatic and Table 1 (Appendix) shows the number of sequenced reads and number reads retrieved from both strands after adapter trimming.



### Human DNA filtering
Human DNA was filtered using BWA with HG38 version of human genome as reference. At the end of the filtering step the reads were divided into 2 files containing Human DNA and non-human DNA for each sample. Table 2 (Appendix) list out the number of human and non-human reads and the human percentage in the samples.

## Taxonomic assignments

Taxonomic assignments were performned using the MetaPhlAn2 program. This software uses a small database of clade-specific marker genes to identify bacterial, fungal, archaeal, and viral taxa in shotgun metagenomics data.  This method sometimes misses low-abundance organisms because of the small database size.  However, taxa identified here are very likely to be authentically present in the data.

Heatmap charts were generated from the taxonomic assignments.  Please see the attached files, `taxonomic_assignments_clustered.pdf` and `taxonomic_assignments_unclustered.pdf`.  In the heatmap charts, each column represents one sample and each row represents one taxon (typically a species).  In the clustered file, samples were arranged by percentage of shared species.  Species were included in the chart if the abundance in any sample exceeded 1%.

The chart is colored white if species were not observed in the sample, dark blue if species were observed at very low abundance.  This allows the reader to quickly survey species presence/absence.  Abundance values exceeding 50% are colored red, indicating an extremely dominant species.

```{r,  echo=FALSE}
remove_rank_prefix <- function (x) {
  gsub("[kpcofgs]__", "", x, perl=TRUE)
}

replace_underscores <- function (x) {
  gsub("_+", " ", x, perl=TRUE)
}

read_metaphlan2_table <- function (filepath, sample_prefix="PCMP_") {
  df <- read.delim(filepath, comment.char="#")
  props <- as.matrix(df[,-1])
  colnames(props) <- sub(sample_prefix, "", colnames(props), fixed = TRUE)
  rownames(props) <- replace_underscores(remove_rank_prefix(df[,1]))
  props
}

props <- read_metaphlan2_table("taxonomic_assignments.tsv")
adf <- split_assignments(rownames(props), split = "\\|")
a <- simplify_assignments(adf, rank2 = "Species")
```

```{r}
plotdata <- props
rownames(plotdata) <- a
maxprops <- apply(plotdata, 1, max)
plotdata <- plotdata[maxprops >= 1,]

plotcolors <- saturated_rainbow(100, saturation_limit = 0.6)
plotbreaks <- c(0, 1e-8, 2:100)

pheatmap(
  plotdata,
  color = plotcolors, breaks = plotbreaks,
  clustering_distance_rows = "binary",
  clustering_distance_cols = "binary",
  main = "Taxa identified by clade-specific marker genes (metaphlan2)",
  filename = "taxonomic_assignments_clustered.pdf",
  cellwidth = 9, cellheight = 9, fontsize = 10)

pheatmap(
  plotdata,
  color = plotcolors, breaks = plotbreaks,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  main = "Taxa identified by clade-specific marker genes (metaphlan2)",
  filename = "taxonomic_assignments_unclustered.pdf",
  cellwidth = 9, cellheight = 9, fontsize = 10)
```

#### Distance analysis: abundance weighted

Here, we use Bray-Curtis distance to compare the species composition of the samples to each other.

The first plot shows the distance between each pair of samples in a single 2D plot.  It is not possible to plot the distances exactly on paper, so we have used a method of ordination called Principal Coordinates Analysis to select the best coordinate system for display.  The percentage of total variance captured along each axis is displayed on the chart.  It is typical for the percentage to be somewhat low if there are many samples, all different in a variety of ways.

```{r}
matrix_to_sample_df <- function (x) {
  df <- data.frame(SampleID=rownames(x), stringsAsFactors = FALSE)
  cbind(df, x)
}

bc <- vegdist(t(props))
pc <- pcoa(bc)
pc_df <- matrix_to_sample_df(pc$vectors[,1:3]) %>%
  inner_join(s, by="SampleID")

pc_pct <- round(pc$values$Relative_eig * 100)
```

```{r, fig.width=6, fig.height=5}
ggplot(pc_df) +
  geom_point(aes_string(x="Axis.1", y="Axis.2", color=color_by)) +
  theme_bw() +
  labs(
    x = paste0("PCoA axis 1 (", pc_pct[1], "%)"),
    y = paste0("PCoA axis 2 (", pc_pct[2], "%)"),
    title = 'Ordination based on Bray-Curtis distance')
```

The second plot shows sample clustering based on Bray-Curtis distance.  We have used a method of hierarchical clustering called "average-linkage" or UPGMA.  At the bottom of the dendrogram, all samples start out in their own group.  Moving up the dendrogram, samples accumulate into clusters if the average (mean) distance between all samples is below the indicated value.

```{r, fig.width=6, fig.height=6}
bc_upgma <- hclust(bc, method = "average")
par(cex=0.5)
plot(
  bc_upgma, hang=-1,
  ylab = "Bray-Curtis distance",
  xlab="Hierarchical clsutering",
  sub="Average-linkage method (UPGMA)")
par(cex=1)
```

#### Distance analysis: presence-absence

Here, we use Jaccard distance to compare samples based on shared species membership.  Plots are described above.

```{r}
jc <- dist(t(props), method = "binary")
pc <- pcoa(jc)

pc_df <- matrix_to_sample_df(pc$vectors[,1:3]) %>%
  inner_join(s, by="SampleID")

pc_pct <- round(pc$values$Relative_eig * 100)
```

```{r, fig.width=6, fig.height=5}
ggplot(pc_df) +
  geom_point(aes_string(x="Axis.1", y="Axis.2", color=color_by)) +
  theme_bw() +
  labs(
    x = paste0("PCoA axis 1 (", pc_pct[1], "%)"),
    y = paste0("PCoA axis 2 (", pc_pct[2], "%)"),
    title = 'Ordination based on Jaccard distance')
```

```{r, fig.width=6, fig.height=6}
bc_upgma <- hclust(bc, method = "average")
par(cex=0.5)
plot(
  bc_upgma, hang=-1,
  ylab = "Jaccard distance",
  xlab="Hierarchical clsutering",
  sub="Average-linkage method (UPGMA)")
par(cex=1)
```


### Functional assignment of reads matching to known genes
Abundance of Kyoto Encyclopedia of Genes and Genomes (KEGG) orthologs (KO) were calculated. Here, we use Bray-Curtis distance to compare the KO composition of the samples to each other.

The plot shows the ordination plot using Principal Coordinates Analysis as described above.

Please see attached file, `gene_function_assignments.pdf`.

```{r,echo=FALSE}
ko <- read.table("ko_assignments.tsv", sep='\t', header=TRUE, stringsAsFactors = FALSE, row.names = 1)
ko <- subset(ko, select = -grep('negative|vibriolambda|crypto', colnames(ko)))
ko <- sweep(ko, 2, colSums(ko), "/")

bc <- vegdist(t(ko), method='bray')
ko_pca <- pcoa(bc)

temp_vectors <- ko_pca$vectors[, 1:5]
rownames(temp_vectors) <- gsub('PCMP_', '', rownames(temp_vectors))
#temp_vectors <- temp_vectors[s$SampleID,]

ko_df <- merge(s, temp_vectors, by.x="SampleID", by.y="row.names")
ko_pct <- round(ko_pca$values$Relative_eig * 100)

g_uu <- ggplot(ko_df, aes(x=Axis.1, y=Axis.2)) +
  coord_equal() +
  theme_bw() +
  xlab(paste0("PCoA axis 1 (", ko_pct[1], "%)")) +
  ylab(paste0("PCoA axis 2 (", ko_pct[2], "%)")) +
  scale_shape_discrete(name=shape_by) + 
  scale_colour_discrete(name=color_by) +
  ggtitle('PCoA plot based on Bray-Curtis distances')

if (shape_by =='' & color_by!='') {
  g_uu <- g_uu + geom_point(aes(colour=factor(get(color_by))))
} else if (shape_by!='' & color_by!='') {
  g_uu <- g_uu + geom_point(aes(colour=factor(get(color_by)), shape=factor(get(shape_by))))
} else {
  g_uu <- g_uu + geom_point()
}
show(g_uu)


#pheatmap(
#  ko, filename = "gene_function_assignments.pdf",
#  cellwidth = 9, cellheight = 9, fontsize = 10)
```

## Appendix

**Table 1: Number of reads before and after trimmming Illumina adapter sequences with Trimmomatic.**

```{r, echo=FALSE}
read.table("preprocess_summary.tsv", header = T) %>%
  mutate(Samples = sub(".json", "", Samples, fixed = TRUE)) %>%
  select(
    Sample = Samples,
    Input = input,
    Dropped = dropped,
    `Forward only` = fwd_only,
    `Reverse only` = rev_only,
    `Both kept` = both_kept) %>%
  pander(split.table = Inf)
```

**Table 2: Number of reads before and after filtering of host genome sequence.**
```{r, echo=FALSE}
read.table("preprocess_summary.tsv", header = T) %>%
  mutate(Samples = sub(".json", "", Samples, fixed = TRUE)) %>%
  mutate(
    `Percent host reads` = 100 * true / (true + false),
    `Percent host reads` = round(`Percent host reads`, 2)) %>%
  select(
    Sample = Samples,
    `Host reads` = true,
    `Non-host reads` = false,
    `Percent host reads`) %>%
  pander(split.table = Inf)
```

